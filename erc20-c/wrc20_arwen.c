

// to avoid includes from libc, just hard-code things
typedef unsigned char uint8_t;
typedef int int32_t;
typedef int uint32_t;
typedef unsigned long long uint64_t;

// types used for Ethereum stuff
typedef uint8_t* bytes; // an array of bytes with unrestricted length
typedef uint8_t bytes32[32]; // an array of 32 bytes
typedef uint8_t address[32]; // an array of 32 bytes
typedef unsigned __int128 u128; // a 128 bit number, represented as a 16 bytes long little endian unsigned integer in memory
//typedef uint256_t u256; // a 256 bit number, represented as a 32 bytes long little endian unsigned integer in memory
typedef uint32_t i32; // same as i32 in WebAssembly
typedef uint32_t i32ptr; // same as i32 in WebAssembly, but treated as a pointer to a WebAssembly memory offset
typedef uint64_t i64; // same as i64 in WebAssembly

// elrond api functions
void getOwner(i32ptr* resultOffset);
void getExternalBalance(i32ptr* addressOffset, i32ptr* resultOffset);
int32_t getBlockHash(long long nonce, i32ptr* resultOffset);
int32_t transfer(long long gasLimit, i32ptr* dstOffset, i32ptr* sndOffset, i32ptr* valueOffset, i32ptr* dataOffset, int32_t length);
int32_t getArgument(int32_t id, i32ptr* argOffset);
int32_t getFunction(i32ptr* functionOffset);
int32_t getNumArguments();
int32_t storageStore(i32ptr* keyOffset, i32ptr* dataOffset, int32_t dataLength);
int32_t storageLoad(i32ptr* keyOffset, i32ptr* dataOffset);
void getCaller(i32ptr* resultOffset);
int32_t getCallValue(i32ptr* resultOffset);
void writeLog(i32ptr* pointer, int32_t length, i32ptr* topicPtr, int32_t numTopics);
void finish(i32ptr* dataOffset, int32_t length);
void signalError();
long long getGasLeft();
long long getBlockTimestamp();

long long int64getArgument(int32_t id);
int32_t int64storageStore(i32ptr* keyOffset, long long value);
long long int64storageLoad(i32ptr* keyOffset);
void int64finish(long long value);

int32_t bigIntNew(int32_t smallValue);
int32_t bigIntByteLength(int32_t reference);
int32_t bigIntGetBytes(int32_t reference, i32ptr* byteOffset);
void bigIntSetBytes(int32_t destination, i32ptr* byteOffset, int32_t byteLength);
int32_t bigIntIsInt64(int32_t reference);
long long bigIntGetInt64(int32_t reference);
void bigIntSetInt64(int32_t destination, long long value);
void bigIntAdd(int32_t destination, int32_t op1, int32_t op2);
void bigIntSub(int32_t destination, int32_t op1, int32_t op2);
void bigIntMul(int32_t destination, int32_t op1, int32_t op2);
int32_t bigIntCmp(int32_t op1, int32_t op2);
void bigIntFinish(int32_t reference);
int32_t bigIntstorageStore(i32ptr* keyOffset, int32_t source);
int32_t bigIntstorageLoad(i32ptr* keyOffset, int32_t destination);
void bigIntgetArgument(int32_t id, int32_t destination);
void bigIntgetCallValue(int32_t destination);
void bigIntgetExternalBalance(i32ptr* addressOffset, int32_t result);



// global data used in next function, will be allocated to WebAssembly memory
bytes32 sender[1] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
bytes32 recipient[1] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
bytes32 subject[1] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

void init() {
  if (getNumArguments() != 1) {
    signalError();
    return;
  }

  getCaller((i32ptr*)sender);
  int32_t totalAmount = bigIntNew(0);
  bigIntgetArgument(0, totalAmount);

  bigIntstorageStore((i32ptr*)sender, totalAmount);
}

void do_balance() {
  if (getNumArguments() != 1) {
    signalError();
    return;
  }

  getArgument(0, (i32ptr*)subject);
  
  int32_t balance = bigIntNew(0);
  bigIntstorageLoad((i32ptr*)subject, balance);

  bigIntFinish(balance);
}

void transfer_token() {
  if (getNumArguments() != 2) {
    signalError();
    return;
  }

  getCaller((i32ptr*)sender);
  getArgument(0, (i32ptr*)recipient);

  int32_t amount = bigIntNew(0);
  bigIntgetArgument(1, amount);

  int32_t senderBalance = bigIntNew(0);
  bigIntstorageLoad((i32ptr*)sender, senderBalance);

  if (bigIntCmp(amount, senderBalance) > 0) {
    signalError();
    return;
  }

  bigIntSub(senderBalance, senderBalance, amount);
  bigIntstorageStore((i32ptr*)sender, senderBalance);

  int32_t receiverBalance = bigIntNew(0);
  bigIntstorageLoad((i32ptr*)recipient, receiverBalance);
  bigIntAdd(receiverBalance, receiverBalance, amount);
  bigIntstorageStore((i32ptr*)recipient, receiverBalance);
}

// global data used in next function, will be allocated to WebAssembly memory
i32 selector[1] = {0};
void _main(void) {
}
